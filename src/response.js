// Generated by CoffeeScript 1.6.3
var Response,
  __slice = [].slice;

// Public: Responses are sent to matching listeners. Messages know about the
// content and user that made the original message, and how to reply back to
// them.
//
// robot   - A Robot instance.
// message - A Message instance.
// match   - A Match object from the successful Regex match.
var Response = function Response(robot, message, match) {
  this.robot = robot;
  this.message = message;
  this.match = match;
  this.envelope = {
    room: this.message.room,
    user: this.message.user,
    message: this.message
  };
}

// Public: Posts a message back to the chat source
//
// strings - One or more strings to be posted. The order of these strings
//           should be kept intact.
//
// Returns nothing.
Response.prototype.send = function() {
  var strings;
  strings = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return this.runWithMiddleware.apply(this, ["send", {
    plaintext: true
  }].concat(__slice.call(strings)));
};

// Public: Posts a message mentioning the current user.
//
// strings - One or more strings to be posted. The order of these strings
//           should be kept intact.
//
// Returns nothing.
Response.prototype.reply = function() {
  var strings;
  strings = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return this.runWithMiddleware.apply(this, ["reply", {
    plaintext: true
  }].concat(__slice.call(strings)));
};

// Private: Call with a method for the given strings using response
// middleware.
Response.prototype.runWithMiddleware = function() {
  var callback, context, copy, methodName, opts, responseMiddlewareDone, runAdapterSend, strings,
    _this = this;
  methodName = arguments[0], opts = arguments[1], strings = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
  callback = void 0;
  copy = strings.slice(0);
  if (typeof copy[copy.length - 1] === 'function') {
    callback = copy.pop();
  }
  context = {
    response: this,
    strings: copy,
    method: methodName
  };
  if (opts.plaintext != null) {
    context.plaintext = true;
  }
  responseMiddlewareDone = function() {};
  runAdapterSend = function(_, done) {
    var result, _ref;
    result = context.strings;
    if (callback != null) {
      result.push(callback);
    }
    (_ref = _this.robot.adapter)[methodName].apply(_ref, [_this.envelope].concat(__slice.call(result)));
    return done();
  };
  return this.robot.middleware.response.execute(context, runAdapterSend, responseMiddlewareDone);
};

// Public: Picks a random item from the given items.
//
// items - An Array of items.
//
// Returns a random item.
Response.prototype.random = function(items) {
  return items[Math.floor(Math.random() * items.length)];
};

// Public: Tell the message to stop dispatching to listeners
//
// Returns nothing.
Response.prototype.finish = function() {
  return this.message.finish();
};

// Public: Creates a scoped http client with chainable methods for
// modifying the request. This doesn't actually make a request though.
// Once your request is assembled, you can call `get()`/`post()`/etc to
// send the request.
//
// Returns a ScopedClient instance.
Response.prototype.http = function(url, options) {
  return this.robot.http(url, options);
};

module.exports = Response;
